# Default values for kube-ceems.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- Provide a name in place of kube-ceems for `app:` labels
#
nameOverride: ""

# -- Override the deployment namespace
#
namespaceOverride: ""

# -- Provide a name to substitute for the full names of resources
#
fullnameOverride: ""

# -- Labels to apply to all resources (can be templated)
#
commonLabels: {}
# scmhash: abc123
# myLabel: aakkmd

# -- Image details
#
image:
  registry: quay.io
  repository: ceems/ceems
  # -- Overrides the image tag whose default is `{{ printf "v%s" .Chart.AppVersion }}`
  tag: ""
  pullPolicy: IfNotPresent
  digest: ""

# -- Global variables
#
# To help compatibility with other charts which use global.imagePullSecrets.
# Allow either an array of `{name: pullSecret}` maps (k8s-style), or an array of strings (more common helm-style).
#
# @raw
#
# ```yaml
# global:
#   imagePullSecrets:
#   - name: pullSecret1
#   - name: pullSecret2
# ```
# or
#
# ```yaml
# global:
#   imagePullSecrets:
#   - pullSecret1
#   - pullSecret2
# ```
#
global:
  # -- (list or object) Image pull secrets.
  imagePullSecrets: []
  # -- Allow parent charts to override registry hostname
  imageRegistry: ""

# -- Monitor current k8s cluster. Setting it to `true` will auto configure CEEMS API server
# and CEEMS LB (if enabled) with configuration corresponding to current cluster.
# Note the deployment based on default values do not use any sort of authentication for
# CEEMS exporter/CEEMS API server/CEEMS LB/Prometheus. If kube-rbac-proxy is enabled
# for CEEMS components the configuration for different components needs to be setup
# manually by using appropriate `Authorization` headers and cluster roles. In that
# case, set this value to `false` and pass the configuration of different CEEMS components
# using corresponding values in chart.
#
monitorCurrentCluster: true

# -- Current cluster ID for CEEMS.
# When `monitorCurrentCluster` is set to `true` and `clusterID` is empty
# a default value of `ceems-k8s-0` will be used. To have a more
# human readable cluster ID we recommend users to set this to unique
# value.
#
clusterID: ""

ceemsExporter:
  # -- Deploys CEEMS exporter
  enabled: true

  imagePullSecrets: []
  # - name: "image-pull-secret"

  # -- Number of old history to retain to allow rollback.
  # Default Kubernetes value is set to 10
  revisionHistoryLimit: 10

  # -- Use RBAC resources
  rbac:
    # -- Create RBAC resources
    create: true
    # -- Any extra cluster roles to be added to CEEMS exporter.
    extraClusterRoleRules: []
    # - apiGroups: []
    #   resources: []
    #   verbs: []

  collectors:
    k8s:
      # -- Enable k8s collector
      enabled: true
      # -- Kubelet pod resources socket directory
      kubeletSocketDirectory: /var/lib/kubelet/pod-resources
    slurm:
      # -- Enable SLURM collector
      enabled: false
      # -- If the SLURM configuration files are located in non-standard location,
      # configure it here.
      configDirectory: /etc/slurm
    libvirt:
      # -- Enable libvirt collector (for Openstack)
      enabled: false
    ipmi:
      # -- Enable IPMI collector
      enabled: false
      # -- IPMI device file path.
      device: /dev/ipmi0
      # -- Monitor power and energy sensor readings
      monitorPowerEnergySensorReadings: false
      # -- Monitor sensor IDs
      monitorSensorIDs: []
    redfish:
      # -- Enable Redfish collector
      enabled: false
      # -- Chassis name(s) that provide power usage of host ONLY (excluding GPU power usage)
      chassisNames: []
      # -- Redfish collector config.
      # More info in [docs](https://ceems-dev.github.io/ceems/docs/configuration/ceems-exporter#redfish-collector)
      config:
        protocol: https
        hostname: ""
        port: 443
        # -- When redfishProxy.enabled is set to true, it will be automatically set to the service URL of redfish proxy
        external_url: ""
        username: ""
        password: ""
        use_session_token: true
        timeout: 5000
    hwmon:
      # -- Enable hwmon collector
      enabled: false
      # -- Chip name(s) that provide power usage of host ONLY (excluding GPU power usage)
      chipNames: []
    crayPMC:
      # -- Enable cray PM counters
      enabled: false
    rapl:
      # -- Enable RAPL collector
      enabled: false
    emissions:
      # -- Enable emissions collector. As only a single instance of emission collector must be
      # run, it is installed as a separate deployment different from daemonset (which runs on all nodes).
      # The deployment will share the same configuration of daemonset except for the keys in the
      # `deploy` section. A very minimal deployment is used for emissions exporter meaning that no
      # extra init containers, secrets, configmaps are mounted.
      #
      # If kube-rbac-proxy is enabled on daemonset, it will be enabled on deployment as well with the
      # same settings.
      enabled: true
      # -- Country code for estimating emissions.
      # By default world average is used. Use an appropriate ISO 3166-1 alpha-2
      # country code to get static emission factors for that country.
      # When a different country code is used, uncomment `owid` provider under
      # `providers` key.
      countryCode: "ZZ"
      # -- Emission factor providers
      providers:
        - global  # World average data reported by IEA (OECD).
        # - owid  # Our World in Data static emission factors
        # - emaps  # Electricity Maps. EMAPS_TOKEN environment variable must be set.
        # - rte  # RTE eCO2 mix
        # - wt  # Watt time. Environment variables WT_USERNAME, WT_PASSWORD and WT_REGION must be set.
      deploy:
        # -- Environment variables to set on emissions exporter deployment.
        # Typically used to setup API keys and login credentials for dynamic emission factor
        # providers
        env: {}
        # -- Affinity for deployment pods where emissions collector
        # will be deployed. The node where this pod will be
        # deployed must have access to internet when dynamic
        # emission factors are enabled.
        #
        affinity: {}
        #   requiredDuringSchedulingIgnoredDuringExecution:
        #     nodeSelectorTerms:
        #       - matchFields:
        #           - key: metadata.name
        #             operator: In
        #             values:
        #               - target-host-name
        # -- Annotations to be added to ceems exporter deployment
        deploymentAnnotations: {}
        # -- Set a `NetworkPolicy` for deployment.
        networkPolicy:
          enabled: false

          # ingress:
          # - {}

          # egress:
          # - {}

  eBPFProfiling:
    # -- Enable eBPF based profiling
    enabled: false

    # -- [Profiling config](https://ceems-dev.github.io/ceems/docs/configuration/ceems-exporter#ebpf-based-continuous-profiling).
    # When `eBPFProfiling.enabled` is set to `true`, config must be provided to include client config of Pyroscope server.
    config: {}

  # -- CEEMS exporter web config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/basic-auth#reference
  webConfig: {}

  # -- Additional arguments for CEEMS exporter.
  # Any other collectors that are not presented under `ceemsExporter.collectors`
  # can be turned on here.
  #
  # List of dicts with `name` and `value` fields. `value` field can be empty for
  # name only arguments.
  # For e.g., for `--collector.k8s --log.level=debug` set the following
  #
  # @raw
  # ```yaml
  # additionalArgs:
  #   - name: collector.k8s
  #   - name: log.level
  #     value: debug
  # ```
  #
  additionalArgs: []
  #   - name: collector.ebpf.io-metrics
  #   - name: collector.redfish
  #   - name: log.level
  #     value: debug

  kubeRBACProxy:
    # -- When enabled, creates a kube-rbac-proxy to protect the CEEMS exporter http endpoint.
    # The requests are served through the same service but requests are HTTPS.
    enabled: false
    # -- Set environment variables as name/value pairs for kube-rbac-proxy.
    env: {}
      # VARIABLE: value

    image:
      registry: quay.io
      repository: brancz/kube-rbac-proxy
      tag: v0.20.0
      sha: ""
      pullPolicy: IfNotPresent

    # -- List of additional CLI arguments to configure kube-rbac-proxy
    # for example: `--tls-cipher-suites`, `--log-file`, etc.
    # All the possible args can be found here: https://github.com/brancz/kube-rbac-proxy#usage
    #
    # Arguments must be passed as list of dicts with `name` and `value`
    # as fields of dict. `value` can be optional for name only arguments.
    #
    # @raw
    #
    # ```yaml
    # additionalArgs:
    #   - name: log-file
    #     value: /path/to/log/file
    # ```
    #
    additionalArgs: []

    # -- Specify security settings for a Container.
    # Allows overrides and additional options compared to (Pod) `securityContext`.
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      privileged: false
      readOnlyRootFilesystem: true

    # -- Specify the port used for the CEEMS exporter container (upstream port)
    port: 8010
    # -- Specify the name of the container port
    portName: http
    # -- Configure a `hostPort`. If `true`, `hostPort` will be enabled in the container and set to service.port.
    enableHostPort: false

    # -- Configure Proxy Endpoints Port
    # This is the port being probed for readiness
    proxyEndpointsPort: 8888

    # -- Configure a `hostPort` for Proxy. If `true`, `hostPort` will be enabled in the container and set to proxyEndpointsPort.
    enableProxyEndpointsHostPort: false

    # -- We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube.
    resources: {}
      ## If you do want to specify resources, uncomment the following
      ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #  cpu: 100m
      #  memory: 64Mi
      # requests:
      #  cpu: 10m
      #  memory: 32Mi

    # -- Additional volume mounts in the kube-rbac-proxy container
    extraVolumeMounts: []
      # - name: extra-volume
      #   mountPath: /extra
      #   readOnly: true

    # -- `tls` enables using TLS resources from a volume on secret referred to in tlsSecret below.
    # When enabling `tlsClientAuth`, client CA certificate must be set in tlsSecret.caItem.
    # Ref. https://github.com/brancz/kube-rbac-proxy/issues/187
    tls:
      enabled: false
      tlsClientAuth: false

  tlsSecret:
    # -- `tlsSecret` refers to an existing secret holding TLS items: client CA certificate, private key and certificate.
    # `secretName` and `volumeName` can be templated.
    # If enabled, volume `volumeName` gets created on secret `secretName`.
    # The volume's resources will be used by kube-rbac-proxy if `kubeRBACProxy.tls.enabled` is set.
    enabled: false
    # -- Key with client CA certificate (optional)
    caItem: ""
    # -- Key with certificate
    certItem: tls.crt
    # -- Key with private key
    keyItem: tls.key
    # -- Name of an existing secret
    secretName: ceems-exporter-tls
    # -- Name of the volume to be created
    volumeName: ceems-exporter-tls

  service:
    # -- Creating a service is enabled by default for CEEMS exporter.
    enabled: true

    # -- Service type
    type: ClusterIP
    # -- IP address for type `ClusterIP`
    clusterIP: ""
    # -- Default service port. Sets the port of the exposed container as well (NE or kubeRBACProxy).
    # Use "servicePort" below if changing the service port only is desired.
    port: 9010
    # -- Service port. Use this field if you wish to set a different service port
    # without changing the container port ("port" above).
    servicePort: ""
    # -- (int or string) Targeted port in the pod. Must refer to an open container port ("port" or "portName").
    targetPort: 9010
    # -- Name of the service port. Sets the port name of the main container (NE) as well.
    portName: metrics
    # -- Port number for service type NodePort
    nodePort: null

    # -- If `true`, CEEMS exporter will listen on all interfaces
    listenOnAllInterfaces: true

    # -- Additional annotations for the service
    annotations:
      prometheus.io/scrape: "true"

    # -- Additional labels for the service
    labels: {}

    # -- Dual stack settings for the service
    # Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services
    ipDualStack:
      enabled: false
      ipFamilies: ["IPv6", "IPv4"]
      ipFamilyPolicy: "PreferDualStack"

    # -- External traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    externalTrafficPolicy: ""

    # -- Internal traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    internalTrafficPolicy: ""

  # -- Set a `NetworkPolicy` for daemonset.
  networkPolicy:
    enabled: false

    # ingress:
    # - {}

    # egress:
    # - {}

  # -- Additional environment variables that will be passed to the daemonset
  env: {}
  #  env:
  #    VARIABLE: value

  prometheus:
    defaultRules:
      # -- Create default rules for CEEMS monitoring. These rules
      # are necessary for Grafana dashboard panels.
      #
      # If default rules are not desired or not enough, additional
      # custom rules to `additionalPrometheusRules` key
      # under `kube-prometheus-stack` section.
      #
      create: true
      rules:
        # -- When there are NVIDIA GPUs in the cluster, enable `nvidiaGPU`
        # rules. NVIDIA GPU operator deploys a DCGM exporter and current
        # helm chart scrapes that exporter based on default labels used.
        # If the deployed DCGM exporter supports profiling metrics, enable
        # `profiling` as well.
        nvidiaGPU:
          enabled: false
          profiling: false

        # -- When there are AMD GPUs in the cluster, enabled `amdGPU` rules.
        # AMD GPU operator deploys a device metrics exporter and current
        # helm chart scrapes that exporter based on default labels used.
        # If `metricsPrefix` in device metrics exporter is used anything other
        # than empty string, set the same here in `metricPrefix`. Similarly
        # when devices metrics exporter is configured to export profiling
        # metrics as well, set `profiling` to true.
        amdGPU:
          enabled: false
          profiling: false
          metricPrefix: ""

      # -- PUE factor to be used in rules for power usage
      pue: 1

      # -- Labels for default CEEMS rules
      labels: {}
      # -- Annotations for default CEEMS rules
      annotations: {}

    monitor:
      # -- Enable Prometheus service monitor
      enabled: true
      # -- When enabled, service monitor for NVIDIA DCGM exporter will be installed to add NVIDIA DCGM exporter to scrape pools.
      # The exporter pods and service can be running in any namespace. There is no need to run them in current chart's namespace.
      dcgmExporterEnabled: false
      # -- When enabled, service monitor for AMD device metrics exporter will be installed to add AMD device metrics exporter to scrape pools.
      # The exporter pods and service can be running in any namespace. There is no need to run them in current chart's namespace.
      amdDeviceMetricsExporterEnabled: false
      # -- Additional labels, e.g. setting a label for pod monitor selector as set in prometheus
      additionalLabels: {}
      # -- Namespace in which to deploy the pod monitor. Defaults to the release namespace.
      namespace: ""
      # -- The label to use to retrieve the job name from. Defaults to label app.kubernetes.io/name.
      jobLabel: ""
      # -- prometheus.monitor.apiVersion ApiVersion for the serviceMonitor Resource(defaults to "monitoring.coreos.com/v1")
      apiVersion: ""
      # -- List of pod labels to add to ceems exporter metrics.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#servicemonitor)
      podTargetLabels: []
      # -- List of target labels to add to ceems exporter metrics.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#servicemonitor)
      targetLabels: []

      # -- Scheme/protocol to use for scraping.
      scheme: http
      # -- BasicAuth allow an endpoint to authenticate over basic authentication.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#basicauth)
      basicAuth: {}
      # -- TLS configuration to use when scraping the endpoint.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#v1.SafeTLSConfig)
      tlsConfig: {}
      # -- Authorization section for this endpoint.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#safeauthorization)
      authorization: {}
      # -- OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#oauth2)
      oauth2: {}

      # -- URL of a proxy that should be used for scraping.
      proxyUrl: ""
      # -- Override serviceMonitor selector
      selectorOverride: {}
      # -- Attach node metadata to discovered targets.
      # Requires Prometheus v2.35.0 and above.
      attachMetadata:
        node: false

      # -- Interval at which endpoints should be scraped. If not specified Prometheus’ global scrape interval is used.
      interval: ""
      # -- Timeout after which the scrape is ended. If not specified, the Prometheus global scrape interval is used.
      scrapeTimeout: 10s
      # -- HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
      honorTimestamps: true
      # -- HonorLabels chooses the metric’s labels on collisions with target labels.
      honorLabels: true
      # -- Whether to enable HTTP2. Default `false`.
      enableHttp2: ""
      # -- Drop pods that are not running. (Failed, Succeeded).
      # Enabled by default. More [info](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)
      filterRunning: ""
      # -- FollowRedirects configures whether scrape requests follow HTTP 3xx redirects. Default `false`.
      followRedirects: ""
      # -- Optional HTTP URL parameters
      params: {}

      # -- RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically adds
      # relabelings for a few standard Kubernetes fields. The original scrape job’s name
      # is available via the __tmp_prometheus_job_name label.
      # More [info](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config)
      relabelings: []
      # -- MetricRelabelConfigs to apply to samples before ingestion.
      metricRelabelings: []

      # -- SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
      sampleLimit: 0
      # -- TargetLimit defines a limit on the number of scraped targets that will be accepted.
      targetLimit: 0
      # -- Per-scrape limit on number of labels that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelLimit: 0
      # --Per-scrape limit on length of labels name that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelNameLengthLimit: 0
      # -- Per-scrape limit on length of labels value that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelValueLengthLimit: 0

    podMonitor:
      # -- Enable Prometheus Pod monitor.
      # `PodMonitor` defines monitoring for a set of pods.
      # Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#podmonitor
      #
      # Using a `PodMonitor` may be preferred in some environments where there is very large number
      # of Node Exporter endpoints (1000+) behind a single service.
      # The `PodMonitor` is disabled by default. When switching from `ServiceMonitor` to `PodMonitor`,
      # the time series resulting from the configuration through `PodMonitor` may have different labels.
      # For instance, there will not be the service label any longer which might
      # affect PromQL queries selecting that label.
      enabled: false
      # -- Namespace in which to deploy the pod monitor. Defaults to the release namespace.
      namespace: ""
      # -- Additional labels, e.g. setting a label for pod monitor selector as set in prometheus
      additionalLabels: {}
      #  release: kube-ceems
      # -- PodTargetLabels transfers labels of the Kubernetes Pod onto the target.
      podTargetLabels: []
      # -- apiVersion defaults to monitoring.coreos.com/v1.
      apiVersion: ""
      # -- Override pod selector to select pod objects.
      selectorOverride: {}
      # -- Attach node metadata to discovered targets. Requires Prometheus v2.35.0 and above.
      attachMetadata:
        node: false
      # -- The label to use to retrieve the job name from. Defaults to label app.kubernetes.io/name.
      jobLabel: ""

      # -- Scheme/protocol to use for scraping.
      scheme: "http"
      # -- Path to scrape metrics at.
      path: "/metrics"

      # -- BasicAuth allow an endpoint to authenticate over basic authentication.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#basicauth)
      basicAuth: {}
      # -- TLS configuration to use when scraping the endpoint.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#v1.SafeTLSConfig)
      tlsConfig: {}
      # -- Authorization section for this endpoint.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#safeauthorization)
      authorization: {}
      # -- OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
      # More [info](https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api-reference/api.md#oauth2)
      oauth2: {}

      # -- ProxyURL eg http://proxyserver:2195. Directs scrapes through proxy to this endpoint.
      proxyUrl: ""
      # -- Interval at which endpoints should be scraped. If not specified Prometheus’ global scrape interval is used.
      interval: ""
      # -- Timeout after which the scrape is ended. If not specified, the Prometheus global scrape interval is used.
      scrapeTimeout: ""
      # -- HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
      honorTimestamps: true
      # -- HonorLabels chooses the metric’s labels on collisions with target labels.
      honorLabels: true
      # -- Whether to enable HTTP2. Default false.
      enableHttp2: ""
      # -- Drop pods that are not running. (Failed, Succeeded).
      # Enabled by default. More [info](https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)
      filterRunning: ""
      # -- `followRedirects` configures whether scrape requests follow HTTP 3xx redirects. Default false.
      followRedirects: ""
      # -- Optional HTTP URL parameters
      params: {}

      # -- `RelabelConfigs` to apply to samples before scraping. Prometheus Operator automatically adds
      # relabelings for a few standard Kubernetes fields. The original scrape job’s name
      # is available via the __tmp_prometheus_job_name label.
      # More [info](https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config)
      relabelings: []
      # -- MetricRelabelConfigs to apply to samples before ingestion.
      metricRelabelings: []

      # -- `SampleLimit` defines per-scrape limit on number of scraped samples that will be accepted.
      sampleLimit: 0
      # -- `TargetLimit` defines a limit on the number of scraped targets that will be accepted.
      targetLimit: 0
      # -- Per-scrape limit on number of labels that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelLimit: 0
      # -- Per-scrape limit on length of labels name that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelNameLengthLimit: 0
      # -- Per-scrape limit on length of labels value that will be accepted for a sample.
      # Only valid in Prometheus versions 2.27.0 and newer.
      labelValueLengthLimit: 0

  # -- Customize the `updateStrategy` if set
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1

  # -- We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube.
  resources: {}
    ## If you do want to specify resources, uncomment the following
    ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

  # -- Specify the container restart policy passed to the CEEMS Exporter container
  # Possible Values: `Always|OnFailure|Never`.
  # Default is `Always`.
  restartPolicy: null

  serviceAccount:
    # -- Specifies whether a ServiceAccount should be created
    create: true
    # -- The name of the ServiceAccount to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    annotations: {}
    imagePullSecrets: []
    # -- Whether to auto mount service token into pods.
    automountServiceAccountToken: true

  # -- Important to set `fsGroup` to read secret mounts. By default exporter will drop privileges and
  # run as `nobody` user. If `--security.run-as-user` is set to a different user, use the primary
  # group ID of that user in `fsGroup`.
  securityContext:
    runAsNonRoot: false
    runAsUser: 0
    fsGroup: 65534

  containerSecurityContext:
    # -- CEEMS components are capability aware which means they drop all the unnecessary privileges
    # based on runtime configuration. It is important to start pods always with privileges as exporter
    # needs privileges for few collectors.
    privileged: true
    # -- Important to make root FS writable to add ACL to necessary files.
    readOnlyRootFilesystem: false
    # capabilities:
    #   add:
    #   - SYS_TIME

  # -- Expose the service to the host network
  hostNetwork: false

  # -- Share the host process ID namespace
  hostPID: false

  # -- Share the host IPC namespace
  hostIPC: false

  # -- Mount the node's root file system (`/`) at `/host/root` in the container
  hostRootFsMount:
    enabled: false
    # -- Defines how new mounts in existing mounts on the node or in the container
    # are propagated to the container or node, respectively. Possible values are
    # `None`, `HostToContainer`, and `Bidirectional`. If this field is omitted, then
    # None is used. More information on:
    # https://kubernetes.io/docs/concepts/storage/volumes/#mount-propagation
    mountPropagation: HostToContainer

  hostProcFsMount:
    # -- Mount the node's proc file system (`/proc`) at `/host/proc` in the container.
    # Possible values are `None`, `HostToContainer`, and `Bidirectional`
    mountPropagation: ""

  hostSysFsMount:
    # -- Mount the node's sys file system (`/sys`) at `/host/sys` in the container.
    # Possible values are `None`, `HostToContainer`, and `Bidirectional`
    mountPropagation: ""

  # -- Assign a group of affinity scheduling rules
  # Affinity for daemon set that run on all the nodes
  #
  affinity: {}
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     nodeSelectorTerms:
  #       - matchFields:
  #           - key: metadata.name
  #             operator: In
  #             values:
  #               - target-host-name

  # -- Annotations to be added to ceems exporter pods
  podAnnotations: {}

  # -- Extra labels to add to ceems exporter pods (can be templated)
  podLabels: {}

  # -- Annotations to be added to ceems exporter daemonset
  daemonsetAnnotations: {}

  # -- Custom DNS configuration to be added to ceems-exporter pods
  dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

  # -- Assign a `nodeSelector` if operating a hybrid cluster
  #
  nodeSelector:
    kubernetes.io/os: linux
    #  kubernetes.io/arch: amd64

  # -- (int) Specify grace period for graceful termination of pods. Defaults to 30 if null or not specified
  terminationGracePeriodSeconds: null

  tolerations:
    - effect: NoSchedule
      operator: Exists

  terminationMessageParams:
    # -- Enable or disable container termination message settings
    # https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/
    enabled: false
    # -- If enabled, specify the path for termination messages
    terminationMessagePath: /dev/termination-log
    # -- If enabled, specify the policy for termination messages
    terminationMessagePolicy: File

  # -- Assign a PriorityClassName to pods if set
  priorityClassName: ""

  # -- Additional mounts from the host to ceems-exporter container
  #
  extraHostVolumeMounts: []
  #  - name: <mountName>
  #    hostPath: <hostPath>
  #    https://kubernetes.io/docs/concepts/storage/volumes/#hostpath-volume-types
  #    type: "" (Default)|DirectoryOrCreate|Directory|FileOrCreate|File|Socket|CharDevice|BlockDevice
  #    mountPath: <mountPath>
  #    readOnly: true|false
  #    mountPropagation: None|HostToContainer|Bidirectional

  # -- Additional configmaps to be mounted.
  #
  configmaps: []
  # - name: <configMapName>
  #   mountPath: <mountPath>

  # -- Additional secrets to be mounted.
  #
  secrets: []
  # - name: <secretName>
  #   mountPath: <mountPatch>

  # -- Extra manifests to deploy as an array
  extraManifests: []
    # - |
    #   apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #     name: prometheus-extra
    #   data:
    #     extra-data: "value"

  # -- Extra volumes to become available in the pod
  extraVolumes: []
    # - name: extra-volume
    #   secret:
    #     defaultMode: 420
    #     optional: false
    #     secretName: ceems-exporter-secret

  # -- Extra volume mounts in the ceems-exporter container
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra
    #   readOnly: true

  # -- Additional InitContainers to initialize the pod
  #
  extraInitContainers: []

  # -- Liveness probe
  #
  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Readiness probe
  #
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Override version of app, required if image.tag is defined and does not follow semver
  version: ""

ceemsAPIServer:
  # -- Deploys ceems api server
  enabled: true

  imagePullSecrets: []
  # - name: "image-pull-secret"

  # -- Number of old history to retain to allow rollback.
  # Default Kubernetes value is set to 10
  revisionHistoryLimit: 10

  rbac:
    # -- Create RBAC resources
    create: true
    # -- Any extra cluster roles to be added to CEEMS exporter.
    extraClusterRoleRules: []
    # - apiGroups: []
    #   resources: []
    #   verbs: []

  admissionWebhooks:
    # -- Enable admission webhook to add username annotations to pods.
    #
    # Must be enabled when monitoring k8s clusters.
    # The controller will add the username annotations to pods which are needed by CEEMS API server
    # to account for energy usage of individual users.
    # By default, admission controller DO NOT STOP any pods from scheduling, it only adds username
    # annotations to the pod's spec.
    enabled: true
    # -- The default timeoutSeconds is 10 and the maximum value is 30.
    timeoutSeconds: 10
    # -- A PEM encoded CA bundle which will be used to validate the webhook's server certificate.
    # If unspecified, system trust roots on the apiserver are used.
    caBundle: ""

    annotations: {}
    #   argocd.argoproj.io/hook: PreSync
    #   argocd.argoproj.io/hook-delete-policy: HookSucceeded

    mutatingWebhookConfiguration:
      annotations: {}
      #   argocd.argoproj.io/hook: PreSync

    validatingWebhookConfiguration:
      annotations: {}
      #   argocd.argoproj.io/hook: PreSync

    deployment:
      # -- Number of replicas
      #
      replicas: 1

      # -- Strategy of the deployment
      #
      strategy: {}

      # -- Number of old replicasets to retain.
      # The default value is 10, 0 will garbage-collect old replicasets.
      revisionHistoryLimit: 10

      # -- Extra arguments to admission controller.
      # List of dicts with `name` and `value` fields for each dict.
      additionalArgs: []

      # -- Service account for CEEMS admission Webhook to use.
      # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
      #
      serviceAccount:
        annotations: {}
        automountServiceAccountToken: false
        create: true
        name: ""

      # -- Configuration for CEEMS admission Webhook service
      #
      service:
        annotations: {}
        labels: {}
        clusterIP: ""
        ipDualStack:
          enabled: false
          ipFamilies: ["IPv6", "IPv4"]
          ipFamilyPolicy: "PreferDualStack"

        # -- Port to expose on each node.
        # Only used if `service.type` is `NodePort`
        #
        nodePort: ""

        # -- Additional ports to open for CEEMS admission Webhook service
        # Ref: https://kubernetes.io/docs/concepts/services-networking/service/#multi-port-services
        #
        additionalPorts: []

        # -- Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints
        #
        externalTrafficPolicy: Cluster

        # -- Service type. Possible values are
        # `NodePort`, `ClusterIP`, `LoadBalancer`
        #
        type: ClusterIP

        # -- List of IP addresses at which the CEEMS admission webhook service is available
        # Ref: https://kubernetes.io/docs/concepts/services-networking/service/#external-ips
        #
        externalIPs: []

      # -- Labels to add to the admission webhook deployment
      #
      labels: {}

      # -- Annotations to add to the admission webhook deployment
      #
      annotations: {}

      # -- Labels to add to the admission webhook pod
      #
      podLabels: {}

      # -- Annotations to add to the admission webhook pod
      #
      podAnnotations: {}

      # -- Assign a PriorityClassName to pods if set
      priorityClassName: ""

      # -- Liveness probe
      #
      livenessProbe:
        enabled: true
        failureThreshold: 3
        initialDelaySeconds: 30
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1

      # -- Readiness probe
      #
      readinessProbe:
        enabled: true
        failureThreshold: 3
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 1

      # -- Resource limits & requests
      #
      resources: {}
      # limits:
      #   cpu: 200m
      #   memory: 200Mi
      # requests:
      #   cpu: 100m
      #   memory: 100Mi

      # -- Define which Nodes the Pods are scheduled on.
      # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
      #
      nodeSelector: {}

      # -- Tolerations for use with node taints
      # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
      ##
      tolerations: []
      # - key: "key"
      #   operator: "Equal"
      #   value: "value"
      #   effect: "NoSchedule"

      # -- Assign custom affinity rules to the prometheus operator
      # Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
      #
      affinity: {}
      # nodeAffinity:
      #   requiredDuringSchedulingIgnoredDuringExecution:
      #     nodeSelectorTerms:
      #     - matchExpressions:
      #       - key: kubernetes.io/e2e-az-name
      #         operator: In
      #         values:
      #         - e2e-az1
      #         - e2e-az2

      dnsConfig: {}
      # nameservers:
      #   - 1.2.3.4
      # searches:
      #   - ns1.svc.cluster-domain.example
      #   - my.dns.search.suffix
      # options:
      #   - name: ndots
      #     value: "2"
      #   - name: edns0

      securityContext:
        fsGroup: 65534
        runAsGroup: 65534
        runAsNonRoot: true
        runAsUser: 65534
        seccompProfile:
          type: RuntimeDefault

      # -- Container-specific security context configuration
      # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
      #
      containerSecurityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
            - ALL

      # -- If `false` then the user will opt out of automounting API credentials.
      #
      automountServiceAccountToken: true

    patch:
      # -- Enable patching webhook to configure TLS CA.
      enabled: true
      image:
        registry: registry.k8s.io
        repository: ingress-nginx/kube-webhook-certgen
        tag: v1.6.4  # latest tag: https://github.com/kubernetes/ingress-nginx/blob/main/images/kube-webhook-certgen/TAG
        sha: ""
        pullPolicy: IfNotPresent
      resources: {}
      ## Provide a priority class name to the webhook patching job
      ##
      priorityClassName: ""
      ttlSecondsAfterFinished: 60
      annotations: {}
      #   argocd.argoproj.io/hook: PreSync
      #   argocd.argoproj.io/hook-delete-policy: HookSucceeded
      podAnnotations: {}
      nodeSelector: {}
      affinity: {}
      tolerations: []

      ## SecurityContext holds pod-level security attributes and common container settings.
      ## This defaults to non root user with uid 2000 and gid 2000. *v1.PodSecurityContext  false
      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
      ##
      securityContext:
        runAsGroup: 2000
        runAsNonRoot: true
        runAsUser: 2000
        seccompProfile:
          type: RuntimeDefault
      ## Service account for Prometheus Operator Webhook Job Patch to use.
      ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
      ##
      serviceAccount:
        create: true
        annotations: {}
        automountServiceAccountToken: true

    # Security context for create job container
    createSecretJob:
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
          - ALL

      # Security context for patch job container
    patchWebhookJob:
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
          - ALL

  # -- CEEMS API server data config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/config-reference#data_config
  #
  dataConfig:
    path: /var/lib/ceems_api_server
    retention_period: 30d
    update_interval: 15m

  # -- CEEMS API server admin config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/config-reference#admin_config
  #
  adminConfig:
    users: []

  # -- CEEMS API server clusters
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/config-reference#cluster_config
  #
  # If `monitorCurrentCluster` is set to `true`, there is no need to add configuration for current
  # cluster. If custom config is needed for current cluster, set `monitorCurrentCluster` to `false`
  # and provide config for current cluster manually here.
  #
  clusters: []

  # -- CEEMS API server updaters
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/config-reference#updater_config
  #
  updaters: []

  # -- CEEMS API server web config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/basic-auth#reference
  webConfig: {}

  # -- Additional arguments for CEEMS API server
  # List of dicts with `name` and `value` fields. `value` field can be empty for
  # name only arguments.
  # For e.g., for `--log.level=debug` set the following
  #
  # @raw
  #
  # ```yaml
  # additionalArgs:
  #   - name: log.level
  #     value: debug
  # ```
  #
  additionalArgs: []
  #   - name: log.level
  #     value: debug


  # Grafana related configuration for CEEMS API server.
  grafana:
    datasource:
      # -- Create a secret to add CEEMS API server as Grafana datasource.
      # This is valid only when `grafana.sidecar.datasources.enabled` is set to `true`
      create: true

      # -- Scheme. http or https
      scheme: http

      # -- Basic auth username and password to connect to datasource
      #
      # @raw
      # Example object:
      #
      # ```yaml
      # basicAuth:
      #   username: user
      #   password: supersecret
      # ```
      #
      basicAuth: {}

      # -- Authentication header name and value to connect to datasource
      #
      # @raw
      # Example object:
      #
      # ```yaml
      # authHeader:
      #   name: Authorization
      #   value: Bearer token
      # ```
      #
      authHeader: {}

      # -- TLS configuration to connect to datasource
      #
      # @raw
      # Example object:
      #
      # ```yaml
      # tls:
      #   authEnabled: false
      #   skipVerify: false
      #   authWithCACert: false
      #   caCert: <CERTIFICATE CONTENT>
      #   clientCert: <CERTIFICATE CONTENT>
      #   clientKey: <CERTIFICATE CONTENT>
      # ```
      #
      tls:
        authEnabled: false

    dashboards:
      # -- Create a config map to load as Grafana dashboards
      # This is valid only when `grafana.sidecar.dashboards.enabled` is set to `true`
      create: true

  # Configure kube-rbac-proxy
  kubeRBACProxy:
    # -- When enabled, creates a kube-rbac-proxy to protect the ceems-api-server and ceems-api-server http endpoint.
    # The requests are served through the same service but requests are HTTPS.
    enabled: false
    # -- Set environment variables as name/value pairs for kube-rbac-proxy
    env: {}
      # VARIABLE: value

    image:
      registry: quay.io
      repository: brancz/kube-rbac-proxy
      tag: v0.20.0
      sha: ""
      pullPolicy: IfNotPresent

    # -- List of additional CLI arguments to configure kube-rbac-proxy
    # for example: `--tls-cipher-suites`, `--log-file`, etc.
    # All the possible args can be found here: https://github.com/brancz/kube-rbac-proxy#usage
    #
    # Arguments must be passed as list of dicts with `name` and `value`
    # as fields of dict. `value` can be optional for name only arguments.
    #
    # @raw
    #
    # ```yaml
    # additionalArgs:
    #   - name: log-file
    #     value: /path/to/log/file
    # ```
    #
    additionalArgs: []

    # -- Specify security settings for a Container.
    # Allows overrides and additional options compared to (Pod) securityContext.
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      privileged: false
      readOnlyRootFilesystem: true

    # -- Specify the port used for the CEEMS API server container (upstream port)
    port: 8020
    # -- Specify the name of the container port
    portName: http
    # -- Configure a hostPort. If true, hostPort will be enabled in the container and set to service.port.
    enableHostPort: false

    # -- Configure Proxy Endpoints Port.
    # This is the port being probed for readiness
    proxyEndpointsPort: 8888
    # -- Configure a hostPort. If true, hostPort will be enabled in the container and set to proxyEndpointsPort.
    enableProxyEndpointsHostPort: false

    # -- We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube.
    resources: {}
      ## If you do want to specify resources, uncomment the following
      ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #  cpu: 100m
      #  memory: 64Mi
      # requests:
      #  cpu: 10m
      #  memory: 32Mi

    # -- Additional volume mounts in the kube-rbac-proxy container.
    extraVolumeMounts: []
      # - name: extra-volume
      #   mountPath: /extra
      #   readOnly: true

    # -- Enables using TLS resources from a volume on secret referred to in `tlsSecret`.
    # When enabling `tlsClientAuth`, client CA certificate must be set in `tlsSecret.caItem`.
    # Ref. https://github.com/brancz/kube-rbac-proxy/issues/187
    tls:
      enabled: false
      tlsClientAuth: false

  tlsSecret:
    # -- `tlsSecret` refers to an existing secret holding TLS items: client CA certificate, private key and certificate.
    # `secretName` and `volumeName` can be templated.
    # If enabled, volume `volumeName` gets created on secret `secretName`.
    # The volume's resources will be used by kube-rbac-proxy if `kubeRBACProxy.tls.enabled` is set.
    enabled: false
    # -- Key with client CA certificate (optional)
    caItem: ""
    # -- Key with certificate
    certItem: tls.crt
    # -- Key with private key
    keyItem: tls.key
    # -- Name of an existing secret
    secretName: ceems-api-server-tls
    # -- Name of the volume to be created
    volumeName: ceems-api-server-tls

  # Service configuration for CEEMS API server
  service:
    # -- Creating a service is enabled by default
    enabled: true

    # -- Service type
    type: ClusterIP
    # -- IP address for type `ClusterIP`
    clusterIP: ""
    # -- Default service port. Sets the port of the exposed container as well (NE or kubeRBACProxy).
    # Use "servicePort" below if changing the service port only is desired.
    port: 9020
    # -- Service port. Use this field if you wish to set a different service port
    # without changing the container port ("port" above).
    servicePort: ""
    # -- (int or string) Targeted port in the pod. Must refer to an open container port (`port` or `portName`).
    targetPort: 9020
    # -- Name of the service port. Sets the port name of the main container (NE) as well.
    portName: metrics
    # -- Port number for service type `NodePort`
    nodePort: null

    # -- If true, CEEMS API server will listen on all interfaces
    listenOnAllInterfaces: true

    # -- Additional annotations and labels for the service
    annotations: {}
    labels: {}

    # -- Dual stack settings for the service
    # Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services
    ipDualStack:
      enabled: false
      ipFamilies: ["IPv6", "IPv4"]
      ipFamilyPolicy: "PreferDualStack"

    # -- External traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    externalTrafficPolicy: ""
    # -- Internal traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    internalTrafficPolicy: ""

  # -- Set a NetworkPolicy with:
  # ingress only on service.port or custom policy
  networkPolicy:
    enabled: false

    # ingress:
    # - {}

    # egress:
    # - {}

  # -- Additional environment variables that will be passed to the deployment
  env: {}
  #  env:
  #    VARIABLE: value

  # -- Customize the `updateStrategy` if set
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1

  # -- We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube.
  resources: {}
    ## If you do want to specify resources, uncomment the following
    ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

  # Enable persistence using Persistent Volume Claims
  # Ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  #
  persistence:
    # -- Enable persistant volumes
    enabled: false
    # -- Type of persistence volume: `pvc` or `statefulset`
    type: pvc
    # -- storageClassName: default
    # (Optional) Use this to bind the claim to an existing PersistentVolume (PV) by name.
    volumeName: ""
    # -- PV access modes.
    accessModes:
      - ReadWriteOnce
    # -- Size of PV.
    size: 10Gi
    # -- annotations: {}
    finalizers:
      - kubernetes.io/pvc-protection
    # selectorLabels: {}
    ## -- Sub-directory of the PV to mount. Can be templated.
    # subPath: ""
    ## -- Name of an existing PVC. Can be templated.
    # existingClaim:
    # -- Extra labels to apply to a PVC.
    extraPvcLabels: {}
    disableWarning: false

    # -- If `persistence` is not enabled, this allows to mount the
    # local storage in-memory to improve performance
    #
    inMemory:
      enabled: false
      ## The maximum usage on memory medium EmptyDir would be
      ## the minimum value between the SizeLimit specified
      ## here and the sum of memory limits of all containers in a pod
      ##
      # sizeLimit: 300Mi

    # -- If `lookupVolumeName` is set to `true`, Helm will attempt to retrieve
    # the current value of `spec.volumeName` and incorporate it into the template.
    lookupVolumeName: true

  # -- Specify the container restart policy passed to the CEEMS API server container
  # Possible Values: `Always|OnFailure|Never`. Default value is `Always`.
  restartPolicy: null

  serviceAccount:
    # -- Specifies whether a `ServiceAccount` should be created
    create: true
    # -- The name of the `ServiceAccount` to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    annotations: {}
    imagePullSecrets: []
    automountServiceAccountToken: true

  securityContext:
    runAsNonRoot: true
    runAsUser: 65534
    runAsGroup: 65534

  containerSecurityContext:
    privileged: false
    readOnlyRootFilesystem: true
    # capabilities:
    #   add:
    #   - SYS_TIME

  # -- Expose the service to the host network
  hostNetwork: false

  # -- Share the host process ID namespace
  hostPID: false

  # -- Share the host IPC namespace
  hostIPC: false

  # -- Assign a group of affinity scheduling rules
  #
  affinity: {}
    # nodeAffinity:
    #   requiredDuringSchedulingIgnoredDuringExecution:
    #     nodeSelectorTerms:
    #       - matchFields:
    #           - key: metadata.name
    #             operator: In
    #             values:
    #               - target-host-name

  # -- Annotations to be added to pods
  podAnnotations: {}

  # -- Extra labels to add to pods (can be templated)
  podLabels: {}

  # -- Annotations to be added to deployment
  deployAnnotations: {}

  # -- Custom DNS configuration to be added to pods
  dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

  # -- Assign a `nodeSelector` if operating a hybrid cluster
  #
  nodeSelector:
    kubernetes.io/os: linux
    #  kubernetes.io/arch: amd64

  # -- (int) Specify grace period for graceful termination of pods. Defaults to 30 if null or not specified
  terminationGracePeriodSeconds: null

  tolerations:
    - effect: NoSchedule
      operator: Exists

  # -- Enable or disable container termination message settings
  # Ref: https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/
  terminationMessageParams:
    enabled: false
    # -- If enabled, specify the path for termination messages
    terminationMessagePath: /dev/termination-log
    # -- If enabled, specify the policy for termination messages
    terminationMessagePolicy: File

  # -- Assign a `PriorityClassName` to pods if set
  priorityClassName: ""

  # -- Additional mounts from the host to CEEMS API server container
  #
  extraHostVolumeMounts: []
  #  - name: <mountName>
  #    hostPath: <hostPath>
  #    https://kubernetes.io/docs/concepts/storage/volumes/#hostpath-volume-types
  #    type: "" (Default)|DirectoryOrCreate|Directory|FileOrCreate|File|Socket|CharDevice|BlockDevice
  #    mountPath: <mountPath>
  #    readOnly: true|false
  #    mountPropagation: None|HostToContainer|Bidirectional

  # -- Additional configmaps to be mounted.
  #
  configmaps: []
  # - name: <configMapName>
  #   mountPath: <mountPath>

  # -- Additional secrets to be mounted.
  #
  secrets: []
  # - name: <secretName>
  #   mountPath: <mountPatch>

  # -- Additional InitContainers to initialize the pod
  #
  extraInitContainers: []

  # -- Extra manifests to deploy as an array
  extraManifests: []
    # - |
    #   apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #     name: prometheus-extra
    #   data:
    #     extra-data: "value"

  # -- Extra volumes to become available in the pod
  extraVolumes: []
    # - name: extra-volume
    #   secret:
    #     defaultMode: 420
    #     optional: false
    #     secretName: ceems-api-server-secret

  # -- Extra volume mounts in the CEEMS API server container
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra
    #   readOnly: true

  # -- Liveness probe
  #
  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Readiness probe
  #
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Override version of app, required if image.tag is defined and does not follow semver
  version: ""

ceemsLB:
  # -- Deploys ceems LB
  enabled: true

  imagePullSecrets: []
  # - name: "image-pull-secret"

  # -- Number of old history to retain to allow rollback
  # Default Kubernetes value is set to 10
  revisionHistoryLimit: 10

  # Use RBAC resources
  rbac:
    # -- Create RBAC resources
    create: true
    # -- Any extra cluster roles to be added to CEEMS exporter.
    extraClusterRoleRules: []
    # - apiGroups: []
    #   resources: []
    #   verbs: []

  # -- CEEMS LB config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/config-reference#ceems_lb
  #
  config: {}


  # -- CEEMS API server related configuration needed for CEEMS LB for imposing
  # access control on Prometheus data.
  #
  ceemsAPIServer:
    # -- PVC for CEEMS API server's storage.
    # For best performance mount the volume that contains CEEMS DB. Provide the
    # persistence volume claim used by the CEEMS API server and PV containing
    # CEEMS DB will be mounted into the CEEMS LB container.
    # Can be templated.
    persistenceVolumeClaim: ""

    # -- HTTP client configuration for CEEMS API server.
    # If provided, access control will be done by sending HTTP requests to
    # CEEMS API server. This is LESS EFFICIENT than mounting the PV containing
    # CEEMS DB directly.
    web: {}

  # -- CEEMS LB web config
  # Ref: https://ceems-dev.github.io/ceems/docs/configuration/basic-auth#reference
  webConfig: {}

  # -- Additional arguments for CEEMS LB
  # List of dicts with `name` and `value` fields. `value` field can be empty for
  # name only arguments.
  # For e.g., for `--log.level=debug` set the following
  #
  # @raw
  #
  # ```yaml
  # additionalArgs:
  #   - name: log.level
  #     value: debug
  # ```
  #
  additionalArgs: []
  #   - name: log.level
  #     value: debug

  # Grafana related configuration for CEEMS LB.
  grafana:
    datasource:
      # -- Create a secret to add CEEMS LB as Grafana datasource.
      # This is valid only when `grafana.sidecar.datasources.enabled` is set to `true`
      create: true

      # -- Scheme. http or https
      scheme: http

      # -- Basic auth username and password to connect to datasource
      #
      # @raw
      #
      # Example object:
      #
      # ```yaml
      # basicAuth:
      #   username: user
      #   password: supersecret
      # ```
      #
      basicAuth: {}

      # -- Authentication header name and value to connect to datasource
      #
      # @raw
      #
      # Example object:
      #
      # ```yaml
      # authHeader:
      #   name: Authorization
      #   value: Bearer token
      # ```
      #
      authHeader: {}

      # -- TLS configuration to connect to datasource
      #
      # @raw
      #
      # Example object:
      #
      # ```yaml
      # tls:
      #   authEnabled: false
      #   skipVerify: false
      #   authWithCACert: false
      #   caCert: <CERTIFICATE CONTENT>
      #   clientCert: <CERTIFICATE CONTENT>
      #   clientKey: <CERTIFICATE CONTENT>
      # ```
      #
      tls:
        authEnabled: false

  # Configure kube-rbac-proxy.
  kubeRBACProxy:
    # -- When enabled, creates a kube-rbac-proxy to protect the CEEMS LB
    # and CEEMS LB http endpoint.
    # The requests are served through the same service but requests are HTTPS.
    enabled: false
    # -- Set environment variables as name/value pairs for kube-rbac-proxy.
    env: {}
      # VARIABLE: value

    image:
      registry: quay.io
      repository: brancz/kube-rbac-proxy
      tag: v0.20.0
      sha: ""
      pullPolicy: IfNotPresent

    # -- List of additional CLI arguments to configure kube-rbac-proxy
    # for example: `--tls-cipher-suites`, `--log-file`, etc.
    # All the possible args can be found here: https://github.com/brancz/kube-rbac-proxy#usage
    #
    # Arguments must be passed as list of dicts with `name` and `value`
    # as fields of dict. `value` can be optional for name only arguments.
    #
    # @raw
    #
    # ```yaml
    # additionalArgs:
    #   - name: log-file
    #     value: /path/to/log/file
    # ```
    #
    additionalArgs: []

    # -- Specify security settings for a Container
    # Allows overrides and additional options compared to (Pod) securityContext
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      privileged: false
      readOnlyRootFilesystem: true

    # -- Specify the port used for the ceems lb container (upstream port)
    port: 8030
    # -- Specify the name of the container port
    portName: http
    # -- Configure a `hostPort`. If true, `hostPort` will be enabled in the container and set to service.port.
    enableHostPort: false

    # -- Configure Proxy Endpoints Port
    # This is the port being probed for readiness
    proxyEndpointsPort: 8888
    # -- Configure a `hostPort`. If true, `hostPort` will be enabled in the container and set to `proxyEndpointsPort`.
    enableProxyEndpointsHostPort: false

    # -- We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube.
    resources: {}
      ## If you do want to specify resources, uncomment the following
      ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #  cpu: 100m
      #  memory: 64Mi
      # requests:
      #  cpu: 10m
      #  memory: 32Mi

    # -- Additional volume mounts in the kube-rbac-proxy container
    extraVolumeMounts: []
      # - name: extra-volume
      #   mountPath: /extra
      #   readOnly: true

    # -- Enables using TLS resources from a volume on secret referred to in `tlsSecret`.
    # When enabling `tlsClientAuth`, client CA certificate must be set in `tlsSecret.caItem`.
    # Ref. https://github.com/brancz/kube-rbac-proxy/issues/187
    tls:
      enabled: false
      tlsClientAuth: false

  tlsSecret:
    # -- `tlsSecret` refers to an existing secret holding TLS items: client CA certificate, private key and certificate.
    # `secretName` and `volumeName` can be templated.
    # If enabled, volume `volumeName` gets created on secret `secretName`.
    # The volume's resources will be used by kube-rbac-proxy if `kubeRBACProxy.tls.enabled` is set.
    enabled: false
    # -- Key with client CA certificate (optional)
    caItem: ""
    # -- Key with certificate
    certItem: tls.crt
    # -- Key with private key
    keyItem: tls.key
    # -- Name of an existing secret
    secretName: ceems-lb-tls
    # -- Name of the volume to be created
    volumeName: ceems-lb-tls

  # Service configuration for CEEMS LB.
  service:
    # -- Creating a service is enabled by default
    #
    # If both TSDB and Pyroscope backends are enabled for CEEMS LB, the TSDB
    # servers can be reached at configured port number (default 9030) and Pyroscope
    # servers can be reached at configured port number plus 10. That means if configured
    # port is 9030, TSDB is available at 9030 and Pyroscope is available at 9040.
    # Consequently the port names will have `-tsdb` and `-pyroscope` suffices.
    enabled: true

    # -- Service type
    type: ClusterIP
    # -- IP address for type `ClusterIP`
    clusterIP: ""
    # -- Default service port. Sets the port of the exposed container as well (NE or kubeRBACProxy).
    # Use `servicePort` below if changing the service port only is desired.
    port: 9030
    # -- Service port. Use this field if you wish to set a different service port
    # without changing the container port (`port` above).
    servicePort: ""
    # -- (int or string) Targeted port in the pod. Must refer to an open container port (`port` or `portName`).
    targetPort: 9030
    # -- Name of the service port. Sets the port name of the main container (NE) as well.
    portName: endpoint
    # -- Port number for service type `NodePort`
    nodePort: null

    # -- If true, CEEMS LB will listen on all interfaces
    listenOnAllInterfaces: true

    # -- Additional annotations and labels for the service
    annotations: {}
    labels: {}

    # -- Dual stack settings for the service
    # Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services
    ipDualStack:
      enabled: false
      ipFamilies: ["IPv6", "IPv4"]
      ipFamilyPolicy: "PreferDualStack"

    # -- External traffic policy setting (Cluster, Local)
    # https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    externalTrafficPolicy: ""
    # -- Internal traffic policy setting (Cluster, Local)
    # https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    internalTrafficPolicy: ""

  # -- Set a NetworkPolicy with:
  # ingress only on service.port or custom policy
  networkPolicy:
    enabled: false

    # ingress:
    # - {}

    # egress:
    # - {}

  # -- Additional environment variables that will be passed to the deployment
  env: {}
  #  env:
  #    VARIABLE: value

  # -- Customize the `updateStrategy` if set
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1

  # -- We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube.
  resources: {}
    ## If you do want to specify resources, uncomment the following
    ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

  # -- Specify the container restart policy passed to the CEEMS Exporter container
  # Possible Values: `Always|OnFailure|Never`. Default value is `Always`.
  restartPolicy: null

  serviceAccount:
    # -- Specifies whether a `ServiceAccount` should be created
    create: true
    # -- The name of the `ServiceAccount` to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    annotations: {}
    imagePullSecrets: []
    automountServiceAccountToken: false

  securityContext:
    runAsGroup: 65534
    runAsNonRoot: true
    runAsUser: 65534

  containerSecurityContext:
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    # capabilities:
    #   add:
    #   - SYS_TIME

  # -- Expose the service to the host network
  hostNetwork: false

  # -- Share the host process ID namespace
  hostPID: false

  # -- Share the host IPC namespace
  hostIPC: false

  # -- Assign a group of affinity scheduling rules
  #
  affinity: {}
    # nodeAffinity:
    #   requiredDuringSchedulingIgnoredDuringExecution:
    #     nodeSelectorTerms:
    #       - matchFields:
    #           - key: metadata.name
    #             operator: In
    #             values:
    #               - target-host-name

  # -- Annotations to be added to pods
  podAnnotations: {}

  # -- Extra labels to add to pods (can be templated)
  podLabels: {}

  # -- Annotations to be added to deployment
  deployAnnotations: {}

  # -- Custom DNS configuration to be added to pods
  dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

  # -- Assign a `nodeSelector` if operating a hybrid cluster
  #
  nodeSelector:
    kubernetes.io/os: linux
    #  kubernetes.io/arch: amd64

  # -- (int) Specify grace period for graceful termination of pods. Defaults to 30 if null or not specified
  terminationGracePeriodSeconds: null

  tolerations:
    - effect: NoSchedule
      operator: Exists

  # -- Enable or disable container termination message settings
  # Ref: https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/
  terminationMessageParams:
    enabled: false
    ## If enabled, specify the path for termination messages
    terminationMessagePath: /dev/termination-log
    ## If enabled, specify the policy for termination messages
    terminationMessagePolicy: File

  # -- Assign a `PriorityClassName` to pods if set
  priorityClassName: ""

  # -- Additional mounts from the host to CEEMS LB container
  #
  extraHostVolumeMounts: []
  #  - name: <mountName>
  #    hostPath: <hostPath>
  #    https://kubernetes.io/docs/concepts/storage/volumes/#hostpath-volume-types
  #    type: "" (Default)|DirectoryOrCreate|Directory|FileOrCreate|File|Socket|CharDevice|BlockDevice
  #    mountPath: <mountPath>
  #    readOnly: true|false
  #    mountPropagation: None|HostToContainer|Bidirectional

  # -- Additional configmaps to be mounted.
  #
  configmaps: []
  # - name: <configMapName>
  #   mountPath: <mountPath>

  # -- Additional secrets to be mounted.
  #
  secrets: []
  # - name: <secretName>
  #   mountPath: <mountPatch>

  # -- Additional InitContainers to initialize the pod
  #
  extraInitContainers: []

  # -- Extra manifests to deploy as an array
  extraManifests: []
    # - |
    #   apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #     name: prometheus-extra
    #   data:
    #     extra-data: "value"

  # -- Extra volumes to become available in the pod
  extraVolumes: []
    # - name: extra-volume
    #   secret:
    #     defaultMode: 420
    #     optional: false
    #     secretName: ceems-lb-secret

  # -- Extra volume mounts in the CEEMS LB container
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra
    #   readOnly: true

  # -- Liveness probe
  #
  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Readiness probe
  #
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Override version of app, required if image.tag is defined and does not follow semver
  version: ""

redfishProxy:
  # -- Deploys redfish proxy
  enabled: false

  imagePullSecrets: []
  # - name: "image-pull-secret"

  # -- Number of old history to retain to allow rollback
  # Default Kubernetes value is set to 10
  revisionHistoryLimit: 10

  # Use RBAC resources
  rbac:
    # -- Create RBAC resources
    create: true
    # -- Any extra cluster roles to be added to redfish proxy.
    extraClusterRoleRules: []
    # - apiGroups: []
    #   resources: []
    #   verbs: []

  # -- If redfish target servers are using self signed TLS certificates, set it to true
  # to skip TLS verfication
  insecureSkipVerify: false

  # -- Additional arguments for redfish proxy
  # List of dicts with `name` and `value` fields. `value` field can be empty for
  # name only arguments.
  # For e.g., for `--log.level=debug` set the following
  #
  # @raw
  #
  # ```yaml
  # additionalArgs:
  #   - name: log.level
  #     value: debug
  # ```
  #
  additionalArgs: []
  #   - name: log.level
  #     value: debug

  # Configure kube-rbac-proxy.
  kubeRBACProxy:
    # -- When enabled, creates a kube-rbac-proxy to protect the redfish proxy and redfish proxy http endpoint.
    # The requests are served through the same service but requests are HTTPS.
    enabled: false
    # -- Set environment variables as name/value pairs
    env: {}
      # VARIABLE: value

    image:
      registry: quay.io
      repository: brancz/kube-rbac-proxy
      tag: v0.20.0
      sha: ""
      pullPolicy: IfNotPresent

    # -- List of additional CLI arguments to configure kube-rbac-proxy
    # for example: `--tls-cipher-suites`, `--log-file`, etc.
    # All the possible args can be found here: https://github.com/brancz/kube-rbac-proxy#usage
    #
    # Arguments must be passed as list of dicts with `name` and `value`
    # as fields of dict. `value` can be optional for name only arguments.
    #
    # @raw
    #
    # ```yaml
    # additionalArgs:
    #   - name: log-file
    #     value: /path/to/log/file
    # ```
    #
    additionalArgs: []

    # -- Specify security settings for a Container
    # Allows overrides and additional options compared to (Pod) securityContext
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      privileged: false
      readOnlyRootFilesystem: true

    # -- Specify the port used for the redfish proxy container (upstream port)
    port: 4000
    # -- Specify the name of the container port
    portName: http
    # -- Configure a `hostPort`. If true, `hostPort` will be enabled in the container and set to service.port.
    enableHostPort: false

    # -- Configure Proxy Endpoints Port
    # This is the port being probed for readiness
    proxyEndpointsPort: 8888
    # -- Configure a `hostPort`. If true, `hostPort` will be enabled in the container and set to `proxyEndpointsPort`.
    enableProxyEndpointsHostPort: false

    # -- We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube.
    resources: {}
      ## If you do want to specify resources, uncomment the following
      ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #  cpu: 100m
      #  memory: 64Mi
      # requests:
      #  cpu: 10m
      #  memory: 32Mi

    # -- Additional volume mounts in the kube-rbac-proxy container
    extraVolumeMounts: []
      # - name: extra-volume
      #   mountPath: /extra
      #   readOnly: true

    # -- Enables using TLS resources from a volume on secret referred to in `tlsSecret` below.
    # When enabling `tlsClientAuth`, client CA certificate must be set in `tlsSecret.caItem`.
    # Ref. https://github.com/brancz/kube-rbac-proxy/issues/187
    tls:
      enabled: false
      tlsClientAuth: false

  tlsSecret:
    # -- `tlsSecret` refers to an existing secret holding TLS items: client CA certificate, private key and certificate.
    # `secretName` and `volumeName` can be templated.
    # If enabled, volume `volumeName` gets created on secret `secretName`.
    # The volume's resources will be used by kube-rbac-proxy if `kubeRBACProxy.tls.enabled` is set.
    enabled: false
    # -- Key with client CA certificate (optional)
    caItem: ""
    # -- Key with certificate
    certItem: tls.crt
    # -- Key with private key
    keyItem: tls.key
    # -- Name of an existing secret
    secretName: redfish-proxy-tls
    # -- Name of the volume to be created
    volumeName: redfish-proxy-tls

  # Service configuration for redfish proxy
  service:
    # -- Creating a service is enabled by default
    enabled: true

    # -- Service type
    type: ClusterIP
    # -- IP address for type `ClusterIP`
    clusterIP: ""
    # -- Default service port. Sets the port of the exposed container as well (NE or kubeRBACProxy).
    # Use `servicePort` below if changing the service port only is desired.
    port: 5000
    # -- Service port. Use this field if you wish to set a different service port
    # without changing the container port (`port` above).
    servicePort: ""
    # -- (int or string) Targeted port in the pod. Must refer to an open container port (`port` or `portName`).
    targetPort: 5000
    # -- Name of the service port. Sets the port name of the main container (NE) as well.
    portName: metrics
    # -- Port number for service type NodePort
    nodePort: null

    # -- If true, redfish proxy will listen on all interfaces
    listenOnAllInterfaces: true

    # -- Additional annotations and labels for the service
    annotations: {}
    labels: {}

    # -- Dual stack settings for the service
    # Ref: https://kubernetes.io/docs/concepts/services-networking/dual-stack/#services
    ipDualStack:
      enabled: false
      ipFamilies: ["IPv6", "IPv4"]
      ipFamilyPolicy: "PreferDualStack"

    # -- External traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    externalTrafficPolicy: ""
    # -- Internal traffic policy setting (Cluster, Local)
    # Ref: https://kubernetes.io/docs/reference/networking/virtual-ips/#traffic-policies
    internalTrafficPolicy: ""

  # -- Set a NetworkPolicy with:
  # ingress only on service.port or custom policy
  networkPolicy:
    enabled: false

    # ingress:
    # - {}

    # egress:
    # - {}

  # -- Additional environment variables that will be passed to the deployment.
  env: {}
  #  env:
  #    VARIABLE: value

  # -- Customize the `updateStrategy` if set
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1

  # -- We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube.
  resources: {}
    ## If you do want to specify resources, uncomment the following
    ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 50Mi
    # requests:
    #   cpu: 100m
    #   memory: 30Mi

  # -- Specify the container restart policy passed to the CEEMS Exporter container
  # Possible Values: `Always|OnFailure|Never`. Default value is `Always`.
  restartPolicy: null

  serviceAccount:
    # -- Specifies whether a `ServiceAccount` should be created
    create: true
    # -- The name of the `ServiceAccount` to use.
    # If not set and create is true, a name is generated using the fullname template
    name:
    annotations: {}
    imagePullSecrets: []
    automountServiceAccountToken: false

  securityContext:
    runAsGroup: 65534
    runAsNonRoot: true
    runAsUser: 65534

  containerSecurityContext:
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    # capabilities:
    #   add:
    #   - SYS_TIME

  # -- Expose the service to the host network
  hostNetwork: false

  # -- Share the host process ID namespace
  hostPID: false

  # -- Share the host IPC namespace
  hostIPC: false

  # -- Assign a group of affinity scheduling rules
  #
  affinity: {}
    # nodeAffinity:
    #   requiredDuringSchedulingIgnoredDuringExecution:
    #     nodeSelectorTerms:
    #       - matchFields:
    #           - key: metadata.name
    #             operator: In
    #             values:
    #               - target-host-name

  # -- Annotations to be added to redfish proxy pods
  podAnnotations: {}

  # -- Extra labels to add to redfish proxy pods (can be templated)
  podLabels: {}

  # -- Annotations to be added to redfish proxy deployment
  deployAnnotations: {}

  # -- Custom DNS configuration to be added to redfish proxy pods
  dnsConfig: {}
  # nameservers:
  #   - 1.2.3.4
  # searches:
  #   - ns1.svc.cluster-domain.example
  #   - my.dns.search.suffix
  # options:
  #   - name: ndots
  #     value: "2"
  #   - name: edns0

  # -- Assign a `nodeSelector` if operating a hybrid cluster
  nodeSelector:
    kubernetes.io/os: linux
    #  kubernetes.io/arch: amd64

  # -- (int) Specify grace period for graceful termination of pods. Defaults to 30 if null or not specified
  terminationGracePeriodSeconds: null

  tolerations:
    - effect: NoSchedule
      operator: Exists

  # -- Enable or disable container termination message settings
  # Ref: https://kubernetes.io/docs/tasks/debug/debug-application/determine-reason-pod-failure/
  terminationMessageParams:
    enabled: false
    # -- If enabled, specify the path for termination messages
    terminationMessagePath: /dev/termination-log
    # -- If enabled, specify the policy for termination messages
    terminationMessagePolicy: File

  # -- Assign a PriorityClassName to pods if set
  priorityClassName: ""

  # -- Additional mounts from the host to redfish-proxy container
  extraHostVolumeMounts: []
  #  - name: <mountName>
  #    hostPath: <hostPath>
  #    https://kubernetes.io/docs/concepts/storage/volumes/#hostpath-volume-types
  #    type: "" (Default)|DirectoryOrCreate|Directory|FileOrCreate|File|Socket|CharDevice|BlockDevice
  #    mountPath: <mountPath>
  #    readOnly: true|false
  #    mountPropagation: None|HostToContainer|Bidirectional

  # -- Additional configmaps to be mounted.
  configmaps: []
  # - name: <configMapName>
  #   mountPath: <mountPath>

  # -- Additional secrets to be mounted.
  secrets: []
  # - name: <secretName>
  #   mountPath: <mountPatch>

  # -- Additional InitContainers to initialize the pod
  extraInitContainers: []

  # -- Extra manifests to deploy as an array
  extraManifests: []
    # - |
    #   apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #     name: prometheus-extra
    #   data:
    #     extra-data: "value"

  # -- Extra volumes to become available in the pod
  extraVolumes: []
    # - name: extra-volume
    #   secret:
    #     defaultMode: 420
    #     optional: false
    #     secretName: redfish-proxy-secret

  # -- Extra volume mounts in the redfish-proxy container
  extraVolumeMounts: []
    # - name: extra-volume
    #   mountPath: /extra
    #   readOnly: true

  # --Liveness probe
  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Readiness probe
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 0
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 1

  # -- Override version of app, required if image.tag is defined and does not follow semver
  version: ""

kubePrometheusStack:
  # -- Deploys kube-prometheus-stack
  enabled: true

# If more configuration is needed, override and/or add new variables that are
# available in kube-ceems.
# Ref: https://github.com/prometheus-community/helm-charts/blob/main/charts/kube-prometheus-stack/values.yaml
#
# Note it is advised to have a separate instance of kube-ceems to monitor
# k8s cluster. The instance that will be installed using current chart is only meant to be used for
# CEEMS components. That is the reason why most of the components are disabled.
kube-prometheus-stack:
  # -- If this is not empty, configs for CEEMS API server and CEEMS LB must be manually provided
  # as service URLs are used based on default fullname of the chart.
  fullnameOverride: ""

  # -- Install Prometheus Operator CRDs.
  # Set it to true if CRDs are not already installed
  ##
  crds:
    enabled: true

  # -- Do not create default rules for monitoring the cluster as
  # this Prometheus instance is not meant to monitor system metrics of
  # cluster.
  #
  defaultRules:
    create: false

  # Manages Prometheus and Alertmanager components
  #
  prometheusOperator:
    # -- Enable prometheus operator
    enabled: true

    # -- Namespaces to scope the interaction of the Prometheus Operator and the apiserver (allow list).
    # This is mutually exclusive with denyNamespaces. Setting this to an empty object will disable the configuration
    #
    namespaces:
      releaseNamespace: true

    kubeletService:
      # -- If true, the operator will create and maintain a service for scraping kubelets
      # Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/helm/prometheus-operator/README.md
      #
      enabled: false

    # -- Do not create Endpoints objects for kubelet targets.
    #
    kubeletEndpointsEnabled: false
    # -- Do not create EndpointSlice objects for kubelet targets.
    #
    kubeletEndpointSliceEnabled: false

  # -- Deploy a Prometheus instance
  #
  prometheus:
    enabled: true

  # Using default values from https://github.com/grafana/helm-charts/blob/main/charts/grafana/values.yaml
  #
  grafana:
    enabled: true

    # -- Necessary configuration as env vars.
    # User header is necessary for proper functionning of
    # CEEMS API server and CEEMS LB datasources.
    env:
      GF_DATAPROXY_SEND_USER_HEADER: true

    # -- Do not deploy default dashboards
    #
    defaultDashboardsEnabled: false

    # -- Admin username
    adminUser: admin
    # -- Admin user password.
    # Use a secure password for production instances
    adminPassword: kube-ceems

    # -- Plugins to install.
    # Infinity datasource is needed for CEEMS API server.
    plugins:
      - yesoreyeram-infinity-datasource

    serviceAccount:
      create: true

    sidecar:
      datasources:
        # -- Enable datasources sidecar.
        enabled: true
        # -- Create default Prometheus datasource.
        defaultDatasourceEnabled: true
        # -- Label that the configmaps with datasources are marked with (can be templated)
        label: kube-ceems-grafana-datasource
        # -- Value of label that the configmaps with datasources are set to (can be templated)
        labelValue: enable
        # -- Search for datasources only in current namespace.
        searchNamespace: ""
        # -- Default datasource name
        name: CEEMS-Prometheus
        # -- Environment variables for sidecar container.
        # If `certificate verify failed` errors are seen in the sidecar logs, it means
        # sidecar container is unable to verify Kubernetes API server's CA certificate.
        # More details can be found in this [GitHub Issue](https://github.com/kiwigrid/k8s-sidecar/issues/400).
        # To circumvent the problem, use `SKIP_TLS_VERIFY: true`. However, note that this is
        # not a formidable solution for production deployments.
        env: {}

        # -- Disable alert manager
        alertmanager:
          enabled: false
      dashboards:
        # -- Enable dashboards sidecar.
        enabled: true
        # -- Label that the configmaps with dashboards are marked with (can be templated)
        label: kube-ceems-grafana-dashboard
        # -- Value of label that the configmaps with dashboards are set to (can be templated)
        labelValue: enable
        # -- Search for dashboards only in current namespace.
        searchNamespace: ""
        # -- Annotation to set the name of the folder
        folderAnnotation: kube-ceems-grafana-dashboard-folder

        # -- Dashboard provider config
        provider:
          # -- name of the provider, should be unique
          name: ceemsSidecarProvider
          # -- Interval at which to check for dashboard updates
          updateIntervalSeconds: 600
          # -- Allow Grafana to replicate dashboard structure from filesystem
          foldersFromFilesStructure: true

        # -- Environment variables for sidecar container.
        # If `certificate verify failed` errors are seen in the sidecar logs, it means
        # sidecar container is unable to verify Kubernetes API server's CA certificate.
        # More details can be found in this [GitHub Issue](https://github.com/kiwigrid/k8s-sidecar/issues/400).
        # To circumvent the problem, use `SKIP_TLS_VERIFY: true`. However, note that this is
        # not a formidable solution for production deployments.
        env: {}

    serviceMonitor:
      # -- If true, a `ServiceMonitor` CRD is created for a prometheus operator
      # Ref: https://github.com/prometheus-operator/prometheus-operator
      #
      enabled: false

  # -- (dict or list) Extra manifests to deploy.  Can be of type dict or list.
  # If dict, keys are ignored and only values are used.
  # Items contained within extraObjects can be defined as dict or string and are passed through tpl.
  extraManifests: null
    # - apiVersion: v1
    #   kind: ConfigMap
    #   metadata:
    #   labels:
    #     name: prometheus-extra
    #   data:
    #     extra-data: "value"
    #
    # can also be defined as a string, useful for templating field names
    # - |
    #   apiVersion: v1
    #   kind: Secret
    #   type: Opaque
    #   metadata:
    #     name: super-secret
    #     labels:
    #       {{- range $key, $value := .Values.commonLabels }}
    #       {{ $key }}: {{ $value }}
    #       {{- end }}
    #   data:
    #     plaintext: Zm9vYmFy
    #     templated: '{{ print "foobar" | upper | b64enc }}'

  # -- Disable thanosRuler
  # Ref: https://thanos.io/tip/components/rule.md/
  #
  thanosRuler:
    enabled: false

  # -- Disable alertmanager
  # Ref: https://prometheus.io/docs/alerting/alertmanager/
  #
  alertmanager:
    enabled: false

  # -- Flag to disable all the kubernetes component scrapers
  #
  kubernetesServiceMonitors:
    enabled: false

  # -- Disable component scraping the kube api server
  #
  kubeApiServer:
    enabled: false

  # -- Disable component scraping the kubelet and kubelet-hosted cAdvisor
  #
  kubelet:
    enabled: false

  # -- Disable component scraping the kube controller manager
  #
  kubeControllerManager:
    enabled: false

  # -- Disable component scraping coreDns. Use either this or kubeDns
  #
  coreDns:
    enabled: false

  # -- Disable component scraping kubeDns. Use either this or coreDns
  #
  kubeDns:
    enabled: false

  # -- Disable component scraping etcd
  #
  kubeEtcd:
    enabled: false

  # -- Disable component scraping kube scheduler
  #
  kubeScheduler:
    enabled: false

  # -- Disable component scraping kube proxy
  #
  kubeProxy:
    enabled: false

  # -- Disable component scraping kube state metrics
  #
  kubeStateMetrics:
    enabled: false

  # -- Disable deploying node exporter as a daemonset to all nodes
  #
  nodeExporter:
    enabled: false

# -- Enable deploying Grafana Pyroscope server.
pyroscopeServer:
  enabled: false

# Using default values from https://github.com/grafana/pyroscope/blob/main/operations/pyroscope/helm/pyroscope/values.yaml
#
pyroscope:
  pyroscope:
    # -- If this is not empty, configs for CEEMS exporter and CEEMS LB must be manually provided
    # as service URLs are used based on default fullname of the chart.
    fullnameOverride: ""

  # -- Disable ingress
  ingress:
    enabled: false

  # -- Disable alloy
  alloy:
    enabled: false

  # -- Disable alloy agent
  agent:
    enabled: false

  # -- Disable minio
  minio:
    enabled: false
